"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const env_1 = require("@things-factory/env");
const lodash_1 = require("lodash");
const typeorm_1 = require("typeorm");
const webPush = require('web-push');
// VAPID keys should only be generated only once.
const vapidKeys = webPush.generateVAPIDKeys();
// webpush.setGCMAPIKey('AIzaSyBL961BMJrB40CaN77pc5STNxUQF6z083I')
webPush.setVapidDetails('https://kimeda.opa-x.com/', vapidKeys.publicKey, vapidKeys.privateKey);
const USER_SUBSCIPTIONS_MAP = {};
const SEND_ALL_PERIOD = 7 * 24 * 60 * 60 * 1000;
var lastSendAllTime = 0;
var gotFromDatabase = false;
// This is the same output of calling JSON.stringify on a PushSubscription
// const pushSubscription = {
//   endpoint: '.....',
//   keys: {
//     auth: '.....',
//     p256dh: '.....'
//   }
// }
async function getSubscriptionsFromDatabase() {
    if (gotFromDatabase)
        return;
    var repo = typeorm_1.getRepository('UserNotification');
    var userNotifications = await repo.find();
    gotFromDatabase = true;
    if (!(userNotifications === null || userNotifications === void 0 ? void 0 : userNotifications.length))
        return;
    userNotifications.forEach((un) => {
        var subscriptions = USER_SUBSCIPTIONS_MAP[un.userId];
        if (!subscriptions)
            subscriptions = USER_SUBSCIPTIONS_MAP[un.userId] = [];
        subscriptions.push(JSON.parse(un.subscription));
    });
}
async function sendNotificationToAll() {
    var now = Date.now();
    await getSubscriptionsFromDatabase();
    if (now - lastSendAllTime > SEND_ALL_PERIOD) {
        for (var userId in USER_SUBSCIPTIONS_MAP) {
            sendNotification({
                receiver: userId,
                message: ''
            });
        }
        lastSendAllTime = now;
    }
}
exports.sendNotificationToAll = sendNotificationToAll;
function sendNotification({ receiver, message }) {
    var subscriptions = USER_SUBSCIPTIONS_MAP[receiver];
    subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.forEach(subscription => {
        sendNotificationTo(subscription, message);
    });
}
exports.sendNotification = sendNotification;
function sendNotificationTo(subscription, message) {
    webPush
        .sendNotification(subscription, message)
        .then(() => {
        env_1.logger.info(message, 'Push Application Server - Notification sent to ' + subscription.endpoint);
    })
        .catch(err => {
        env_1.logger.warn('ERROR in sending Notification, endpoint removed ' + subscription.endpoint);
        unregisterSubscription({
            subscription
        });
    });
}
function getVapidPublicKey() {
    return vapidKeys.publicKey;
}
exports.getVapidPublicKey = getVapidPublicKey;
async function register({ request: req }) {
    var { subscription, user } = req.body;
    if (!subscription || !user)
        return false;
    // var authCheckURL = new URL('/authcheck', req.URL).toString()
    // var response = await fetch(authCheckURL, {
    //   headers: {
    //     cookie: req.headers.cookie
    //   }
    // })
    // var userInfo = await response.json()
    // if (!userInfo) return false
    // var userId = userInfo.user.id
    registerSubscription({
        userId: user,
        subscription
    });
}
exports.register = register;
async function unregister(req) {
    var subscription = req.body.subscription;
    unregisterSubscription({
        subscription
    });
}
exports.unregister = unregister;
function registerSubscription({ userId, subscription }) {
    var userSubscriptions = USER_SUBSCIPTIONS_MAP[userId];
    if (!userSubscriptions)
        userSubscriptions = USER_SUBSCIPTIONS_MAP[userId] = [];
    var found = findSubscription(subscription);
    if (!found)
        userSubscriptions.push(subscription);
    debouncedSaveSubscriptions();
    return true;
}
function unregisterSubscription({ subscription }) {
    var empties = [];
    for (var userId in USER_SUBSCIPTIONS_MAP) {
        var userSubscriptions = USER_SUBSCIPTIONS_MAP[userId];
        var subscriptionIdx = userSubscriptions.findIndex(s => {
            return s.endpoint == subscription.endpoint;
        });
        if (subscriptionIdx > -1)
            userSubscriptions.splice(subscriptionIdx, 1);
        if (userSubscriptions.length == 0)
            empties.push(userId);
    }
    empties.forEach(userId => {
        delete USER_SUBSCIPTIONS_MAP[userId];
    });
    debouncedSaveSubscriptions();
    return true;
}
function findSubscription(subscription) {
    for (var userId in USER_SUBSCIPTIONS_MAP) {
        var userSubscriptions = USER_SUBSCIPTIONS_MAP[userId];
        var found = userSubscriptions.find(s => {
            return s.endpoint == subscription.endpoint;
        });
        if (found)
            return found;
    }
    return null;
}
async function saveSubscriptions() {
    var repo = typeorm_1.getRepository('UserNotification');
    var userNotifications = [];
    for (var userId in USER_SUBSCIPTIONS_MAP) {
        var subscriptions = USER_SUBSCIPTIONS_MAP[userId];
        subscriptions.forEach(subscription => {
            userNotifications.push({
                userId,
                subscription: JSON.stringify(subscription)
            });
        });
    }
    if (userNotifications.length) {
        await repo.clear();
        repo.save(userNotifications);
    }
}
var debouncedSaveSubscriptions = lodash_1.debounce(saveSubscriptions, 100);
//# sourceMappingURL=notifications.js.map