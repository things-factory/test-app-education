"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
process.env.NODE_ENV = 'development';
process.setMaxListeners(0);
const koa_1 = __importDefault(require("koa"));
const koa2_cors_1 = __importDefault(require("koa2-cors"));
const koa_static_1 = __importDefault(require("koa-static"));
const koa_bodyparser_1 = __importDefault(require("koa-bodyparser"));
const koa2_connect_history_api_fallback_1 = require("koa2-connect-history-api-fallback");
const koa_webpack_1 = __importDefault(require("koa-webpack"));
const apollo_server_koa_1 = require("apollo-server-koa");
const graphql_upload_1 = require("graphql-upload");
const graphql_1 = require("graphql");
const subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
const env_1 = require("@things-factory/env");
const database_1 = require("./initializers/database");
const routes_1 = require("./routes");
const schema_1 = require("./schema");
require("./middlewares");
const args = require('args');
args.option('port', 'The port on which the app will be running', env_1.config.get('port', 3000));
args.option('inspect', 'The address on which the inspection will be running. Used in development mode only.', env_1.config.get('inspect', ':9229'));
const flags = args.parse(process.argv);
const path = require('path');
const webpack = require('webpack');
const webpackConfig = require('../webpack.config.dev.js');
const compiler = webpack(webpackConfig);
const PORT = (process.env.PORT = flags.port);
const UPLOAD_DIR = (process.env.UPLOAD_DIR = env_1.config.getPath('uploads', 'uploads'));
const bodyParserOption = {
    formLimit: '10mb',
    jsonLimit: '10mb',
    textLimit: '10mb'
};
/* bootstrap */
const bootstrap = async () => {
    await database_1.databaseInitializer();
    const app = new koa_1.default();
    app.use(koa2_cors_1.default({
        origin: function (ctx) {
            var origin = ctx.request.headers.origin;
            if (origin) {
                return origin;
            }
            else {
                return '*';
            }
        },
        exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'],
        maxAge: 5,
        credentials: true,
        allowMethods: ['GET', 'POST', 'DELETE'],
        allowHeaders: ['Content-Type', 'Authorization', 'Accept']
    }));
    app.on('error', (err, ctx) => {
        env_1.logger.error(err);
        /* centralized error handling:
         *   console.log error
         *   write error to log file
         *   save error and request information to database if ctx.request match condition
         *   ...
         */
    });
    /* history fallback */
    var fallbackOption = {
        whiteList: [
            `^\/(${[
                'graphql',
                'graphiql',
                'file',
                'uploads',
                'dependencies',
                'licenses',
                'vapidPublicKey',
                'register',
                'unregister',
                'request-notification'
            ].join('|')})($|[/?#])`
        ]
    };
    process.emit('bootstrap-module-history-fallback', app, fallbackOption);
    app.use(koa2_connect_history_api_fallback_1.historyApiFallback(fallbackOption));
    /* authentication error handling */
    app.use(async (ctx, next) => {
        return next().catch(err => {
            if (err.status === 401) {
                ctx.status = 401;
                ctx.body = {
                    error: err.originalError ? err.originalError.message : err.message
                };
            }
            else {
                throw err;
            }
        });
    });
    const server = new apollo_server_koa_1.ApolloServer({
        schema: schema_1.schema,
        subscriptions: {
            path: '/subscriptions'
        },
        formatError: error => {
            env_1.logger.error(error);
            return error;
        },
        formatResponse: response => {
            // logger.info('response %s', JSON.stringify(response, null, 2))
            return response;
        },
        context: ({ ctx }) => ctx
    });
    process.emit('bootstrap-module-middleware', app);
    const render = require('koa-ejs-remote');
    render(app, {
        root: '/views',
        host: `http://127.0.0.1:${PORT}`,
        layout: false,
        viewExt: 'html',
        cache: false,
        debug: false
    });
    koa_webpack_1.default({
        compiler,
        hotClient: {},
        devMiddleware: {
            publicPath: webpackConfig.output.publicPath,
            stats: { colors: true }
        }
    }).then(middleware => {
        app.use(middleware);
        app.use(koa_bodyparser_1.default(bodyParserOption));
        /* jwt 인증에 graphql middleware를 포함하기 위해서 jwt 인증 설정 다음에 둔다. */
        server.applyMiddleware({
            app
        });
        /* 개발 환경에서는 두개의 graphql path를 둔다.
          /graphql : application 에서 사용.
          /graphiql : graphql test UI 에서 사용.
    
          /graphql 을 test UI에서 시도하면, authcheck 대상에 해당되어, 미인증 이유로 테스트가 불가능하기 때문이다.
        */
        server.applyMiddleware({
            path: '/graphiql',
            app
        });
        app.use(graphql_upload_1.graphqlUploadKoa({ maxFileSize: 10000000, maxFiles: 10 }));
        app.use(koa_static_1.default(path.join(webpackConfig.output.path), {
            index: false
        }));
        process.emit('bootstrap-module-route', app, routes_1.routes);
        app.use(routes_1.routes.routes());
        app.use(routes_1.routes.allowedMethods());
        var httpServer = app.listen({ port: PORT }, () => {
            env_1.logger.info(`🚀 Server ready at http://0.0.0.0:${PORT}${server.graphqlPath}`);
            env_1.logger.info(`🚀 Subscriptions ready at ws://0.0.0.0:${PORT}${server.subscriptionsPath}`);
            process.emit('bootstrap-module-start', { app, config: env_1.config, schema: schema_1.schema });
        });
        subscriptions_transport_ws_1.SubscriptionServer.create({
            schema: schema_1.schema,
            execute: graphql_1.execute,
            subscribe: graphql_1.subscribe
            // onConnect: (connectionParams, webSocket, context) => {
            //   console.log('connectionParams', connectionParams)
            //   try {
            //     const { user } = jwt.verify(connectionParams.authToken, env('AUTH_SECRET'))
            //     const jwtData = jwtDecode(connectionParams.authToken)
            //     const timeout = jwtData.exp * 1000 - Date.now()
            //     debugPubSub('authenticated', jwtData)
            //     debugPubSub('set connection timeout', timeout)
            //     setTimeout(() => {
            //       // let the client reconnect
            //       socket.close()
            //     }, timeout)
            //     return { subscriptionUser: user }
            //   } catch (error) {
            //     debugPubSub('authentication failed', error.message)
            //     return { subscriptionUser: null }
            //   }
            // },
            // onOperation(message: string, params: Object) {
            //   setTimeout(() => {
            //     R.forEach((todo: Todo) => {
            //       pubsub.publish(TODO_UPDATED_TOPIC, { todoUpdated: todo })
            //       debugPubSub('publish', TODO_UPDATED_TOPIC, todo)
            //     }, todos)
            //   }, 0)
            // return Promise.resolve(params)
            // },
            // onDisconnect: (webSocket, context) => {}
        }, {
            server: httpServer,
            path: '/subscriptions'
        });
    });
};
bootstrap();
//# sourceMappingURL=server-dev.js.map